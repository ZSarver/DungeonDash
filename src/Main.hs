{-# LANGUAGE RecordWildCards #-}
{-# LANGUAGE RecursiveDo #-}

import Keyboard (keyDownEvents, Key( .. ))
import Types
import Render
import SignalUtils
import Vector
import Random
import Enemy (enemiesInit, enemiesStep)
import Event
import Player (playerInit, playerStep)

import FRP.Helm hiding (Time)
import FRP.Helm.Time(fps)
import FRP.Helm.Sample (Sample)
import FRP.Elerea.Param hiding (Signal)
import qualified FRP.Elerea.Param as E
import System.Random (Random, randomRIO,mkStdGen,randomIO)
import Control.Applicative
import Data.Traversable (sequenceA)
import Control.Monad.IO.Class (liftIO)


{-
So here's the plan:
We'll have a few top level signals with fixed dependencies. All signals will
be created at initialization and destroyed when things end. Since the 
dependency network is fixed, we will never end up with wacky types of the form 
"Signal Signal a".
 - ENEMIES 
    -- Has internal state (hence needs transfer type stuff)
    -- describes the current state of all enemies
    -- depends on EVENTS
              and PLAYER
 - PLAYER
    -- Has internal state (hence needs transfer type stuff)
    -- describes the current state of the player
    -- depends on EVENTS
 - EVENTS
    -- Has NO internal state. Should be generated by lifting pure functions
    -- Should probably change the type to be more constraining.
    -- describes interactions that have consequences on multiple signals,
       including (but maybe not limited to?) attacks
    -- depends on ENEMIES
              and PLAYER
              and INPUT
 - INPUT
   -- keyboard, mouse, game clock, etc
   -- no dependencies on any part of the signal network
 - DISPLAY
   -- This is the only part that really needs to touch helm stuff.
   -- What gets drawn to the screen
   -- depends on PLAYER
             and ENEMIES
   -- since only main depends on this, we don't need to give a 
      name to the signal
 - maybe more later? this is enough for now.
    - eventually we may want a signal for the CAMERA, 
       if it isn't always just centered on the player
    - we may also want signals for ITEMS, BLOOD_SPLATTERS, 
       SIMULATION_SPEED_MULTIPLIER, or other special effects
-}
randomPosition :: Rand Position
randomPosition = Vec2 <$> range (-500,500) <*> range (-500,500)

spawnWhen :: E.Signal Bool -> E.Signal (Rand [Event])
spawnWhen s = fmap f s
  where
  f True = (\p -> [SpawnEnemy p]) <$> randomPosition
  f False = pure []

evalRandomSignal :: Rng -> E.Signal (Rand a) -> E.SignalGen p (E.Signal a)
evalRandomSignal g s = effectful1 (withRng g) s

elapsedTime = stateful 0 (+)

-- every primetime signal time, time!
every :: Time -> E.SignalGen Time (E.Signal Bool)
every t = (fmap.fmap) snd $ stateful (0,False) f
  where  f dt (acc,_) = let acc' = dt + acc in 
                           if acc' > t 
                           then (acc' - t, True)
                           else (acc', False)
       

game :: Int -> E.SignalGen Time (E.Signal (Sample (Enemies,Player)))
game seed = mdo
  rng <- liftIO $ mkRng seed
  let events = fmap concat . sequenceA $ 
        [ attacks
        , spawns
        , hits
        ]
      spaceDown = elem SpaceKey <$> keys
  keys <- keyDownEvents [UpKey,DownKey,LeftKey,RightKey,SpaceKey]
  enemies <- transfer2 enemiesInit enemiesStep player events
  player <- transfer playerInit playerStep events
  attacks <- delay eventsInit $ getAttacks <$> keys <*> player <*> enemies
  hits <- delay eventsInit $ getHits <$> player
  spawns <- evalRandomSignal rng =<< fmap spawnWhen (every 1000)
  return $ fmap pure $ liftA2 (,) enemies player

  
main = do
  stepGame <- start $ game 12345
  let game' = Signal $ effectful (stepGame 0.8)
      enemies = fmap fst game'
      player = fmap snd game'
  run config $ refresh $ render 800 600 <~ player ~~ enemies
  where
    config = defaultConfig { windowTitle = "Dungeon Dash!", windowPosition = (200,200) }
    refresh s = const <~ s ~~ (fps 40)
