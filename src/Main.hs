{-# LANGUAGE RecordWildCards #-}
{-# LANGUAGE RecursiveDo #-}

import Keyboard (keyDownEvents, Key( .. ))
import Types
import Render
import SignalUtils
import Vector
import Random
import Enemy (enemiesInit, enemiesStep)
import Event (eventsInit, eventsStep)
import Player (playerInit, playerStep)

import FRP.Helm
import FRP.Helm.Time(fps)
import FRP.Helm.Sample (Sample)
import FRP.Elerea.Param hiding (Signal)
import qualified FRP.Elerea.Param as E
import System.Random (Random, randomRIO,mkStdGen,randomIO)
import Control.Applicative
import Data.Traversable (sequenceA)



{-
So here's the plan:
We'll have a few top level signals with fixed dependencies. All signals will
be created at initialization and destroyed when things end. Since the 
dependency network is fixed, we will never end up with wacky types of the form 
"Signal Signal a".
 - ENEMIES 
    -- Has internal state (hence needs transfer type stuff)
    -- describes the current state of all enemies
    -- depends on EVENTS
              and PLAYER
 - PLAYER
    -- Has internal state (hence needs transfer type stuff)
    -- describes the current state of the player
    -- depends on EVENTS
 - EVENTS
    -- Has NO internal state. Should be generated by lifting pure functions
    -- Should probably change the type to be more constraining.
    -- describes interactions that have consequences on multiple signals,
       including (but maybe not limited to?) attacks
    -- depends on ENEMIES
              and PLAYER
              and INPUT
 - INPUT
   -- keyboard, mouse, game clock, etc
   -- no dependencies on any part of the signal network
 - DISPLAY
   -- This is the only part that really needs to touch helm stuff.
   -- What gets drawn to the screen
   -- depends on PLAYER
             and ENEMIES
   -- since only main depends on this, we don't need to give a 
      name to the signal
 - maybe more later? this is enough for now.
    - eventually we may want a signal for the CAMERA, 
       if it isn't always just centered on the player
    - we may also want signals for ITEMS, BLOOD_SPLATTERS, 
       SIMULATION_SPEED_MULTIPLIER, or other special effects
-}
randomPosition :: Rand Position
randomPosition = Vec2 <$> range (-400,400) <*> range (-300,300)

spawnWhen :: E.Signal Bool -> E.Signal (Rand [Event])
spawnWhen s = fmap f s
  where
  f True = (\p -> [SpawnEnemy p]) <$> randomPosition
  f False = pure []

evalRandomSignal :: Rng -> E.Signal (Rand a) -> E.SignalGen p (E.Signal a)
evalRandomSignal g s = effectful1 (withRng g) s

elapsedTime = stateful 0 (+)

game :: Rng -> E.SignalGen Double (E.Signal (Sample (Enemies,Player)))
game rng = mdo
  let events = fmap concat . sequenceA $ 
        [ events1
        , spawns
        ]
      spaceDown = elem SpaceKey <$> keys
  keys <- keyDownEvents [UpKey,DownKey,LeftKey,RightKey,SpaceKey]
  enemies <- transfer2 enemiesInit enemiesStep player events
  player <- transfer playerInit playerStep events
  events1 <- delay eventsInit =<< transfer3 eventsInit eventsStep keys player enemies
  spawns <- evalRandomSignal rng $ spawnWhen spaceDown
  return $ fmap pure $ liftA2 (,) enemies player

main = do
  rng <- mkRng =<< randomIO
  stepGame <- start $ game rng
  let game' = Signal $ effectful (stepGame 0.8)
      enemies = fmap fst game'
      player = fmap snd game'
  run config $ refresh $ render 800 600 <~ player ~~ enemies
  where
    config = defaultConfig { windowTitle = "Dungeon Dash!", windowPosition = (200,200) }
    refresh s = const <~ s ~~ (fps 40)
